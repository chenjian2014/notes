# 垃圾回收

垃圾回收算法

1. 引用计数法
   原理: 任何对对象 A 的引用都会使A 的引用计数+1; 引用对象被删除则-1; 为 0 则回收掉
   优点: 实时性高
   缺点: 每次都要更新, 无法解决循环引用的问题

2. 标记清除
   标记: 从根节点开始标记对象
   清除: 未被标记的对象需要被清除
   缺点: STW, 内存碎片化严重

3. 标记压缩
   标记: 从根节点开始标记对象
   压缩: 将标记对象压缩到内存一端, 清理边界外对象
   优点: 解决内存碎片化问题

4. 复制算法
   将内存分为两块, 每次只用其中一块, 垃圾回收时, 将存活对象复制到另一块
   缺点: 适用于垃圾较多的情况, 内存利用率低
   与标记压缩区别: 
       标记压缩因为有标记阶段, 所以耗时多, 但是只需要一块内存
       复制算法没有单独标记的阶段, 所以耗时少, 但是耗内存高
   标记压缩: 时间换空间
   复制算法: 空间换时间

5. 分代
   jvm 分为年轻代和老年代, 年轻代用复制算法, 老年代用标记清除或压缩



### golang 垃圾回收

根对象:
    是垃圾回收器最先检查的对象, 包括:
    全局变量, 执行栈, 寄存器

goland 的GC 是 无分代, 不整理, 并发的三色标记清除算法

三色标记法
    白色对象: 未被回收器访问到的对象
    灰色对象: 正被回收器检查的对象
    黑色对象: 已扫描完成的对象, 确认存活

写屏障:
    Dijkstra 插入屏障和 Yuasa 删除屏障

gc 细节:
    标记准备阶段, 开启写屏障, STW
    扫描标记阶段, 写屏障开启, 并发操作
    标记终止阶段, 关闭写屏障, STW
    内存清扫阶段, 内存归还到堆, 写屏障关闭, 并发操作
    内存归还阶段, 内存归还操作系统, 写屏障关闭, 并发操作

触发 gc:
    主动触发: runtime.GC
    被动触发: 
        超过两分钟没有 GC, 强制 GC;
        超过内存阈值



### python 垃圾回收

