# 分布式事务

## 二阶段提交

1. 提交事务请求

   1. 事务询问

      协调者向参与者发送事务内容, 询问是否可以执行事务, 并等待响应(问题点: 超时会阻塞协调者)

   2. 执行事务

      参与者执行事务操作, 写 undo 和 redo

   3. 参与者反馈

      返回成功或失败响应, 同时等待

2. 执行事务提交

   如果协调者收到的都是成功响应, 则执行事务提交

   1. 发送提交请求

      协调者向所有参与者发送 commit 请求

   2. 事务提交

      参与者收到 commit 请求后, 正式提交事务, 释放事务资源

   3. 反馈结果

      参与者完成事务, 发送 ack 消息

   4. 完成事务

      协调者收到所有 ack 后, 完成事务

   如果有参与者反馈失败响应, 则中断事务

   1. 发送回滚请求
   2. 事务回滚
   3. 反馈回滚结果
   4. 中断事务


问题:

1. 同步阻塞
2. 单点问题
3. 数据不一致
4. 太过保守

## 三阶段提交

1. CanCommit

   1. 事务询问

      协调者发送 canCommit 请求

   2. 反馈

      参与者反馈 yes 或者 no

2. PreCommit

   如果都是 yes, 则 进入事务预提交

   1. 发送预提交请求

      协调者发送 preCommit 请求, 进入 prepared 阶段

   2. 事务预提交

      参与者收到 preCommit 请求后, 执行事务操作, 记录 redo 和 undo

   3. 反馈

      参与者发送 ack 响应, 同时等待协调者指令

   如果有 no, 则中断事务

   1. 发送中断请求

      协调者发送 abort 请求

   2.   中断事务

        收到协调者 abort 或者等待协调者请求超时, 参与者中断事务 

3. doCommit

   如果协调者收到所有 ack, 进入执行提交

   1. 发送请求

      协调者发送 doCommit 请求

   2. 事务提交

      参与者收到请求, 提交事务, 并释放资源. **参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交**(这里也就是不太保守, 因为有了 CanCommit, 所以一定程度可保证正确)

   3. 反馈结果

      参与者完成事务, 发送 ack 消息

   4. 完成事务

      协调者收到所有 ack 后, 完成事务

   如果有参与者反馈 no, 则中断事务

   1. 发送回滚请求
   2. 事务回滚
   3. 反馈回滚结果
   4. 中断事务



## 二阶段和三阶段的主要区别

个人认为三阶段把二阶段的第一阶段拆分成了两部分 CanCommit 和 PreCommit

CanCommit 通过增加询问, 以后随后收到的反馈, 确保了在开始执行事务操作之前, 协调者和参与者都是 ok 的. 后续其实没有区别.

**至于说引入超时机制, 大概是指三阶段里面3.2 参与者超时会继续执行吧, 不太清楚**

所以三阶段其实也就是勉强解决了二阶段单点和太过保守的问题, 因为即便协调者超时或者挂了, 事务也大概率会成功, 但显然不完美