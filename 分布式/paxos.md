# paxos 算法

### 目标

多个进程选出一个值

### 角色

- proposer 提议者
- acceptor 决策者
- learner 学习者

各角色是不可靠的, 角色间通信可能超时, 重复或者丢失, 但是消息不会损坏或者被篡改

### 算法

提案格式: [Mn, Vn]

第一阶段:

1. 提议者生成提案, 编号n, 无值, 向决策者发送 prepare请求; 
2. 决策者收到提案, 如果编号大于之前响应过的提案, 则反馈提议者已经批准的提案[Mx, Vx], 并以后不批准比 n 小的提案

第二阶段:

1. 提议者收到过半数响应, 则发送一个[Mn, Vn]的 accept 请求, 其中 对于Vn是所有响应中 Mx 最大的 Vx, 如果 Vx 不存在, 则任意值.

2. 决策者只要没有响应比 n 大的请求, 就接受 accept 请求.

关键点:

1. 提议者, 决策者, 学习者都是集合, 提议者只负责提案, 决策者才保有值, 学习者从决策者获取结果

2. 决策者接受一个值后, 就只会更新编号, 值一直不变

3. 提议者收到过半数响应后, 值生成, 然后以后就不会再变.
4. 提议者收到的过半数响应中, 要不都没值, 要不 有值的都一样, 并且比没值的编号大.

learner学习:

​	learner 从每个决策者获取结果, 从而确定被大多数决策者接受的值.	



# ZAB 算法

### 角色

leader

follower

事务 ZXID: 高 32 位为 leader 轮次, 低 32 位消息次数, 都是递增的

### 三个阶段

特性: 崩溃恢复和消息广播

选举, 同步, 广播

选举:

1. 每个 server 发出一票 (myid, ZXID)
2. Server 对收到的选票 pk, 规则: 1, ZXID 大的获胜, 否则: 2. 机器 id 大的获胜. 将结果票发出去
3. 过半数即为 leader

同步: 

​	根据 ZXID, 同一轮次则执行, 反馈给 leader, leader 收到过半反馈发送 commit

广播:

​	leader 接受消息, 发送给 follower, follower 处理事务, leader 收到过半 ack, 发送commit. follower提交事务.	



# raft 算法

角色:

leader

follower

candidate

阶段:

leader 选举:

​	在每个任期 term(自增加 1), 候选者会进行选举, 获取大多数票则当选. 如果失败, 则超时(随机超时)等待下一次选举.

日志复制:

​	leader 接受客户端命令, 记录日志, 然后向 follower 发送, 收到大多数反馈则提交

