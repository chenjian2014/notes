### 归并排序

稳定的排序方法, 缺点耗内存

是一种典型的分治算法

```python
def merge(left, right):
    result = []
    i = 0
    j = 0
    tmp = 0
    while i < len(left) and j < len(right):
        tmp += 1
        print(tmp)
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    if i == len(left):
        for x in right[j:]:
            result.append(x)
    else:
        for x in left[i:]:
            result.append(x)

    return result


def sort(data):
    if len(data) <= 1:
        return data

    left = data[:len(data) >> 1]
    right = data[len(data) >> 1:]
    left = sort(left)
    right = sort(right)
    result = merge(left, right)
    return result

```

### 快速排序

```python
def quick_sort(array):
    left = 0
    right = len(array)
    sort(array, left, right)

def sort(array, left, right):
    if left < right:
        index = partition(array, left, right)
        sort(array, left, index)
        sort(array, index+1, right)

def partition(array, left, right):
    x = array[left]
    index = left + 1

    for i in range(index, right):
        if array[i] < x:
            array[index], array[i] = array[i], array[index]
            index += 1

    array[left], array[index-1] = array[index-1], array[left]
    return index - 1

```

